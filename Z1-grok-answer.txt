Привет! Я проанализировал твою проблему на основе официальной документации Apple (Xcode 15.4, iOS SDK 17.5/18.x), GitHub Actions guides и аналогичных кейсов (включая issues по embedding Swift runtime в unsigned builds). Кратко: Ошибка краша на iOS 18.4.1 (swift::fatalError в libswiftCore.dylib) указывает на несовместимый или отсутствующий Swift runtime (вероятно, берётся старая версия из toolchain для iOS 12.2, которая не совместима с iOS 18). Это классическая проблема unsigned builds: Apple не позволяет полноценно embed Swift stdlibs без signing, так как dylibs (типа libswiftCore.dylib) требуют codesign для валидации. Твои попытки (ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES, manual copy, swift-stdlib-tool) берут старые версии, потому что по умолчанию toolchain fallback на минимальную supported iOS (12.x в Xcode 15.4).

**Самый простой и надёжный способ в CI без локального Mac**: Перейди на signed IPA с development certificate. Unsigned builds не предназначены для runtime embedding (Apple docs подчёркивают, что для distribution нужен sign). Это работает в GitHub Actions (macos-14 runner), не требует модификации Godot, и совместимо с Yandex SDK 7.5.0 (Swift 5). Static linkage в CocoaPods помогает, но не полностью решает для runtime dylibs — они всё равно требуют embed/sign. Если настаиваешь на unsigned — фикс с swift-stdlib-tool возможен, но хрупкий (см. ниже).

Вот конкретные ответы и инструкции. Всё адаптировано для твоей конфигурации (Godot 4.4.1, Xcode 15.4, iOS 13.0+, macos-14).

### 1. Где находятся правильные Swift libraries для iOS 17.5/18.4 в Xcode 15.4?
- **Основной путь к stdlibs**: В Xcode 15.4 Swift runtime libraries (.dylib) для конкретных iOS версий находятся в toolchain: `/Applications/Xcode_15.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift-5.0/iphoneos/` (или swift-5.10 для новых, но в 15.4 — swift-5.0).
  - Здесь версии для minimal deployment (iOS 12.2+), но для iOS 17.5/18.4 берётся актуальная (back-deployed для compatibility). Нет отдельных .dylib per iOS version — runtime unified, но back-compat modules в `/usr/lib/swift/` внутри SDK.
- **В iOS SDK**: Stubs (.tbd) в `/Applications/Xcode_15.4.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/swift/` — это link-time stubs, не runtime dylibs. Реальные runtime dylibs копируются из toolchain во время build/archive.
- **Почему берётся старая версия (iOS 12.2)**: В unsigned build swift-stdlib-tool/manual copy fallback на minimal supported (12.2 в Xcode 15.4 iOS SDK 17.5). Для iOS 18 нужно указывать --minimum-deployment-target или использовать signed build, где embed automatic.

### 2. Как правильно копировать Swift libraries для unsigned IPA?
- **Официальный способ**: Используй `swift-stdlib-tool` с параметрами для target version. Но в unsigned build это не всегда работает идеально (Apple рекомендует sign для embed dylibs). Добавь --minimum-deployment-target=17.0 (или 18.0) и --toolchain для правильного toolchain.
- **Точная команда в CI (после xcodebuild build, перед packaging в IPA)**:
  ```bash
  APP_PATH="path/to/your.app"  # Путь к .app в build/Release-iphoneos/
  SWIFT_TOOLCHAIN="/Applications/Xcode_15.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain"
  
  swift-stdlib-tool \
    --copy \
    --scan-executable "$APP_PATH/ios_xcode" \
    --scan-folder "$APP_PATH/Frameworks" \
    --platform iphoneos \
    --toolchain "$SWIFT_TOOLCHAIN" \
    --minimum-deployment-target 17.0 \  # Или 18.0 для compatibility
    --destination "$APP_PATH/Frameworks"
  ```
  - Это скопирует актуальные .dylib (из swift-5.0 для iOS 17+). Затем codesign stubs (но для unsigned — пропусти или используй ldid для fake sign, но это неофициально и рискованно для CI).
- **Другой способ**: Manual copy из правильного пути:
  ```bash
  SWIFT_LIBS="/Applications/Xcode_15.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift-5.0/iphoneos"
  cp -r "$SWIFT_LIBS"/*.dylib "$APP_PATH/Frameworks/"
  ```
  - Но добавь strip для версии: `lipo -thin arm64 -output libswiftCore.dylib libswiftCore.dylib` (для arm64 only).
- **Проблема**: Без signing dylibs не валидируются на iOS 18.4 (fatalError). Лучше signed.

### 3. Альтернативные подходы
- **Signed IPA с development certificate в GitHub Actions** (рекомендую — это идеальное решение для CI):
  - Да, возможно без локального Mac: Загрузи cert и provisioning profile как secrets. GitHub docs описывают процесс.
  - **Шаги**:
    1. На локальном Mac (один раз): Создай development cert в Keychain (Certificates > Request from CA), экспортируй .p12 (с password). Создай provisioning profile (developer.apple.com > Profiles > Development) для твоего app ID и devices.
    2. В repo settings > Secrets: Добавь APPLE_CERT_P12_BASE64 (base64-encoded .p12), APPLE_CERT_PASSWORD, PROVISIONING_PROFILE_BASE64 (base64-encoded .mobileprovision).
    3. В .yml workflow (macos-14):
       ```yaml
       - name: Import Apple Certificate
         env:
           CERT_P12_BASE64: ${{ secrets.APPLE_CERT_P12_BASE64 }}
           CERT_PASSWORD: ${{ secrets.APPLE_CERT_PASSWORD }}
           PROVISIONING_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
         run: |
           echo "$CERT_P12_BASE64" | base64 --decode > certificate.p12
           security create-keychain -p pwd ~/Library/Keychains/temp.keychain
           security default-keychain -s ~/Library/Keychains/temp.keychain
           security unlock-keychain -p pwd ~/Library/Keychains/temp.keychain
           security import certificate.p12 -k ~/Library/Keychains/temp.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign
           echo "$PROVISIONING_BASE64" | base64 --decode > profile.mobileprovision
           mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
           cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
       
       - name: Build and Archive
         run: |
           xcodebuild -workspace ios_xcode.xcworkspace \
             -scheme ios_xcode \
             -configuration Release \
             -sdk iphoneos \
             -archivePath build/YourApp.xcarchive \
             archive \
             CODE_SIGN_IDENTITY="iPhone Developer" \  # Или твой cert name
             PROVISIONING_PROFILE_SPECIFIER="YourProfileName" \  # Из .mobileprovision
             ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES  # Теперь работает с sign
       
       - name: Export IPA
         run: |
           xcodebuild -exportArchive \
             -archivePath build/YourApp.xcarchive \
             -exportPath build/YourApp.ipa \
             -exportOptionsPlist ExportOptions.plist  # Plist с method=development, compileBitcode=NO
       ```
    - Это embed Swift runtime автоматически (для iOS 17.5/18.4). Установи на iPhone через Sideloadly (с тем же cert).
- **Заставить CocoaPods embed правильно**: В Podfile используй `use_frameworks! :linkage => :static` — это statically links Swift code, минимизируя runtime dylibs. Но для Yandex SDK (mixed) некоторые dylibs остаются — добавь в post_install:
  ```ruby
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES'] = 'YES'
      config.build_settings['SWIFT_VERSION'] = '5.0'  # Для Yandex 7.5.0
    end
  end
  ```
  - Затем pod install в CI. Но для unsigned — всё равно нужен sign для dylibs.
- **Сборка локально на Mac и использование в CI**: Не нужно — CI на macos-14 эквивалентен локальному Mac. Если для теста: Собери локально signed, upload artifact в CI для дальнейших шагов.

### 4. Почему CocoaPods не embeds Swift libraries автоматически?
- С `use_frameworks! :linkage => :static` CocoaPods statically links pod code (включая Swift), но Swift runtime (core dylibs) — это system-level, не pod-specific. Он embeds только если ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES и build signed (codesign required для dylib validation). Для Yandex (Swift 5) runtime не fully static — остаются dynamic parts для compatibility. Static linkage уменьшает размер, но не устраняет runtime embed.

**Рекомендация**: Начни с signed IPA (п.3) — это решит краш на iOS 18.4.1 (runtime embedded correctly). Если unsigned критичен — используй обновлённый swift-stdlib-tool + ldid для fake sign dylibs (но нестабильно). Если ошибки в CI — кинь логи, уточню.