Привет! Я разобрался с твоей проблемой на основе документации clang и Apple по работе с XCFrameworks в command line. Основная ошибка в твоей команде: флаг `-F` ожидает путь к **директории**, содержащей .xcframework (не сам файл .xcframework). Если YandexMobileAds.xcframework лежит в текущей директории, используй `-F.` (точку). Clang автоматически выберет нужный слайс (ios-arm64) на основе архитектуры (-arch arm64). Для Objective-C++ компиляции в GitHub Actions (macOS runner) также нужны флаги для iOS SDK, минимальной версии iOS и Objective-C runtime (например, -fobjc-arc, если используешь ARC).

Вот ответы на вопросы:

### 1. Как правильно указать путь к XCFramework для clang?
- Укажи `-F` с путём к директории, где лежит .xcframework (не к самому файлу). Clang будет искать фреймворки там, включая headers внутри (типа ios-arm64/YandexMobileAds.framework/Headers/YandexMobileAds.h).
- Если .xcframework в текущей директории: `-F.`
- Если в поддиректории (например, frameworks/): `-Fframeworks`
- Это позволит #import <YandexMobileAds/YandexMobileAds.h> найти хедер без дополнительных -I.

### 2. Нужно ли указывать -F на ios-arm64 папку?
- Нет, не нужно. Clang автоматически парсит структуру XCFramework и выбирает правильный слайс (ios-arm64) на основе флагов компиляции, таких как `-arch arm64` и `-isysroot` для iOS SDK. Указание -F на внутреннюю папку (ios-arm64) сломает поиск, так как clang ожидает корневую директорию с .xcframework.

### 3. Или нужно использовать -I вместо -F?
- Нет, -I используется для raw include директорий (не для фреймворков). Для XCFramework правильнее -F, чтобы clang правильно обработал фреймворк (headers, linking metadata). Если используешь -I, то укажи полный путь к Headers (например, -I./YandexMobileAds.xcframework/ios-arm64/YandexMobileAds.framework/Headers), но это хрупко и не рекомендуется — потеряешь преимущества фреймворка (автоматический поиск, модульность).

### 4. Какие флаги нужны для компиляции против XCFramework?
- `-F<dir>`: Для поиска XCFramework.
- `-arch arm64`: Архитектура (для iPhone 16+ устройств).
- `-x objective-c++`: Явно указать язык (если расширение .mm не подхватывается).
- `-fobjc-arc`: Включить Automatic Reference Counting (стандарт для modern Objective-C; если не используешь ARC, убери).
- `-isysroot $(xcrun --sdk iphoneos --show-sdk-path)`: Путь к iOS SDK (автоматически берётся из xcrun).
- `-miphoneos-version-min=13.0`: Минимальная версия iOS (замени на твою, например, 13.0 для Yandex SDK).
- `-c`: Только компиляция в .o (без linking).
- Опционально: `-o file.o` для вывода объекта.

### Точная команда clang для GitHub Actions (macOS runner)
Предполагаю, что:
- YandexMobileAds.xcframework лежит в текущей директории.
- Файл для компиляции: file.mm.
- Минимальная iOS: 13.0 (как в Yandex SDK 7.17.1).
- Используем xcrun для правильного окружения (стандарт в GitHub Actions macOS runners, где Xcode установлен).

```bash
xcrun clang -x objective-c++ -arch arm64 -fobjc-arc -isysroot $(xcrun --sdk iphoneos --show-sdk-path) -miphoneos-version-min=13.0 -F. -c file.mm -o file.o
```

- **Как использовать в GitHub Actions workflow (.yml)**:
  ```yaml
  - name: Compile Objective-C++ file
    run: |
      # Предполагаем, что xcframework скачан/скопирован в текущую директорию
      xcrun clang -x objective-c++ -arch arm64 -fobjc-arc -isysroot $(xcrun --sdk iphoneos --show-sdk-path) -miphoneos-version-min=13.0 -F. -c file.mm -o file.o
  ```
- Если ошибка persists: Проверь наличие xcframework (`ls YandexMobileAds.xcframework/ios-arm64/YandexMobileAds.framework/Headers/YandexMobileAds.h`). Добавь -v для verbose вывода clang (чтобы увидеть поиск путей). Если нужны другие фреймворки (например, UIKit), добавь -framework UIKit.

Если после этого ошибка в логах, кинь детали — уточню команду!