Привет! Я разобрал твою проблему на основе официальной документации Godot 4.4.1 (включая раздел по iOS плагинам), форумов и аналогичных случаев (например, linking errors из-за name mangling в C++/Objective-C++). Кратко: ошибка возникает из-за несоответствия в name mangling. Твоя функция `yandex_ads_init` компилируется с `extern "C"` (C-style имя: `_yandex_ads_init`), но Godot генерирует `dummy.cpp` (C++ файл), где вызов `yandex_ads_init()` ожидает C++-mangled имя (например, `_Z18yandex_ads_initv`), потому что нет declaration с `extern "C"`. Линкер видит C-символ в `.a`, но не может связать с mangled запросом из `dummy.o`. Это классическая проблема interoperability C/C++ (подтверждено в похожих кейсах на Godot форумах и Stack Overflow).

Yandex SDK (7.5.0 через CocoaPods) здесь не при чём — проблема чисто в плагине. CocoaPods правильно добавляет SDK (если post_install hook настроен для embedding Swift runtime, как в твоих попытках), но linking падает на твоём символе. Forward declarations OK, но нужен header и пост-процессинг для фикса.

Вот ответы на вопросы с конкретными инструкциями. Это позволит собрать IPA в GitHub Actions (macos-14, Xcode 15.4). Решение работает без модификации Godot engine, фокусируется на CI-workflow (простой патч `dummy.cpp` после экспорта).

### 1. Как правильно экспортировать C функции из Objective-C++ файла для Godot 4.4.1?
- Да, используй `extern "C"` (как у тебя), чтобы избежать C++ mangling и сделать символы C-compatible (Godot ожидает именно C-символы для init/deinit).
- Но ключ: Добавь header (.h) с declarations — это позволит линкеру правильно resolve символы. Без .h компилятор в `dummy.cpp` не знает о `extern "C"` и предполагает C++ linkage.
- Компиляцию оставь как есть (Objective-C++ via clang++), но включи .h в процесс и XCFramework.

**Инструкции:**
- Создай `yandex_ads.h` в `ios/plugins/yandex_ads/`:
  ```objective-c
  #ifndef YANDEX_ADS_H
  #define YANDEX_ADS_H

  #ifdef __cplusplus
  extern "C" {
  #endif

  void yandex_ads_init();
  void yandex_ads_deinit();

  #ifdef __cplusplus
  }
  #endif

  #endif
  ```
- В `yandex_ads.mm` добавь `#include "yandex_ads.h"` в начало (после imports).
- Обнови `build_plugins.sh` (компиляция + headers в XCFramework):
  ```bash
  # Компилируем в .o (добавь -I. для local headers, если нужно)
  xcrun clang++ \
      -x objective-c++ \
      -std=c++17 \
      -arch arm64 \
      -isysroot $(xcrun --sdk iphoneos --show-sdk-path) \
      -mios-version-min=13.0 \
      -c yandex_ads.mm \
      -o yandex_ads_device.o \
      -fobjc-arc

  # Создаём статическую библиотеку
  ar rcs libyandex_ads_device.a yandex_ads_device.o

  # Создаём headers директорию (копируем .h)
  mkdir -p headers
  cp yandex_ads.h headers/

  # Создаём XCFramework с headers (для public access в XCode)
  xcodebuild -create-xcframework \
      -library libyandex_ads_device.a \
      -headers headers \
      -output yandex_ads.xcframework
  ```
- Для симулятора: Повтори с `-sdk iphonesimulator -arch arm64` (или x86_64), создай отдельную .a, затем объедини в XCFramework с несколькими -library.

Это сделает символы видимыми как C (без mangling), и headers позволят XCode/Godot знать о них.

### 2. Нужен ли header файл (.h) с объявлениями для .gdip?
- Да, обязателен для правильной линковки в Godot 4.4.1. `.gdip` не обрабатывает declarations — он только указывает на binary и имена функций. Без .h в XCFramework компилятор в generated коде (dummy.cpp) не видит `extern "C"`, что приводит к mangling mismatch.
- Включи .h как выше (в headers при create-xcframework). Godot/XCode автоматически добавит -F для фреймворка, но для вызова в dummy.cpp всё равно нужен патч (см. ниже), так как Godot не генерирует #include автоматически.

Обнови `.gdip` (добавь зависимости для Yandex, если не через CocoaPods):
```ini
[config]
name="YandexAds"
binary="yandex_ads.xcframework"
initialization="yandex_ads_init"
deinitialization="yandex_ads_deinit"

[dependencies]
embedded=[]
system=["UIKit.framework", "Foundation.framework"]
linker_flags=["-ObjC"]
```

### 3. Может ли проблема быть в том, что Godot генерирует dummy.cpp который не знает про extern "C"?
- Да, именно это! Godot 4.4.1 генерирует `dummy.cpp` (или аналогичный файл, как `GodotPluginDummy.cpp` в экспортированном проекте) с вызовами init/deinit как обычными C++ функциями, без `extern "C"` или #include твоего .h. Компилятор предполагает C++ linkage (mangling), но твоя .a имеет C-символы. Результат: linker error.
- Это известная проблема в Godot iOS plugins (форумы упоминают подобное для 4.x; docs помечены как WIP и не детализируют фикс).

### 4. Как заставить Godot генерировать правильные объявления в dummy.cpp?
- Godot не позволяет кастомизировать generated код напрямую (это internal). Workaround: Пост-процессинг `dummy.cpp` в GitHub Actions после экспорта проекта. Добавь `extern "C"` declarations перед вызовами — это заставит компилятор использовать C linkage.
- Альтернатива: Перейди на GDExtension (рекомендуется в Godot 4+, но для iOS требует recompilation engine с scons). Или используй полный Xcode проект для плагина вместо command line (с public headers).

**Инструкции для патча в GitHub Actions (.yml):**
- После шага экспорта Godot (предполагаю, генерируешь `ios_xcode.xcodeproj` в `path/to/exported/`):
  ```yaml
  - name: Patch dummy.cpp for extern "C"
    run: |
      DUMMY_FILE=$(find path/to/exported -name "*dummy.cpp" | head -1)  # Найди dummy.cpp (обычно src/dummy.cpp или src/godot_ios_plugins.cpp)
      if [ -f "$DUMMY_FILE" ]; then
        sed -i '' '/void godot_ios_plugins_initialize()/i \
        extern "C" void yandex_ads_init();\
        extern "C" void yandex_ads_deinit();\
        ' "$DUMMY_FILE"
        echo "Patched $DUMMY_FILE"
      else
        echo "dummy.cpp not found!"
        exit 1
      fi
  ```
- Затем продолжай с `pod install` (для Yandex SDK) и `xcodebuild`:
  ```bash
  # ... (pod install если используешь CocoaPods)
  xcodebuild -workspace ios_xcode.xcworkspace \
      -scheme ios_xcode \
      -configuration Release \
      -sdk iphoneos \
      build
  ```
- Если используешь CocoaPods: В post_install hook (в Podfile) добавь:
  ```ruby
  post_install do |installer|
    installer.pods_project.targets.each do |target|
      if target.name == 'Pods-ios_xcode'
        target.build_configurations.each do |config|
          config.build_settings['ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES'] = 'YES'
          config.build_settings['OTHER_LDFLAGS'] ||= ['-ObjC']
        end
      end
    end
  end
  ```
  Это обеспечит embedding Swift runtime для Yandex 7.5.0 (mixed Obj-C/Swift).

### Ожидаемое решение: Полная последовательность
1. **Подготовь файлы**: Добавь `yandex_ads.h`, обнови `yandex_ads.mm` и `build_plugins.sh` (как выше). Commit в repo.
2. **В CI**: 
   - Build плагин (`build_plugins.sh`).
   - Экспорт Godot: `godot --export-release "iOS" path/to/exported.xcodeproj --headless`.
   - Патч `dummy.cpp` (как выше).
   - `pod install` (если Yandex через Pods).
   - `xcodebuild build` (как у тебя).
3. **Тест**: Собери IPA, установи на iPhone (Sideloadly). В логах (idevicesyslog) ищи "SDK initialized". Если OK — плагин инициализирован, символы найдены.
4. **Если error persists**: Проверь nm libyandex_ads_device.a | grep yandex_ads_init — должен показать _yandex_ads_init (C-style). Если mangled — удали extern "C" из реализации (но оставь в declarations).

Это решит за 30-60 мин (тест в CI). Если нужны детали Podfile или полный .yml — кинь. Удачи!